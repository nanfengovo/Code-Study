# await async 成对出现
# 不支持异步方法的情况
* 使用.Result(有返回值的情况)
* 使用.wait（没有返回值）
上面的两种方式有死锁的风险

# async await 原理

> 底层是movenext 类似于状态机的机制去切换

# 异步方法不等于多线程

# 异步方法可以不写async

# 暂停使用 await Task.Delay

# 异步中的CancellationToken

> 提高系统的健壮性和性能

>场景：有时用户需要提前终止任务，比如：请求超时，用户取消请求 。这时CancellationToken参数用于获得提前终止执行的信号


## CancellationToken结构体
None:空
bool IsCancellationRequested 是否取消
Register(Action calllback) 注册取消监听
ThrowIfCancellationRequested() 如果任务被取消，执行到这句话就抛异常
通过CancellationTokenSource 创建cancellationtoken结构体
CancelAfter() 超时后发出取消信号
Cancel()  发出取消信号

## Demo
> 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现

### CancelAfter+IsCancellationRequested
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(1000); // 5秒后取消

            await Download2Async("https://www.baidu.com", 100,cts.Token);

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    if (cancellationToken.IsCancellationRequested)
                    {
                        Console.WriteLine("下载任务被取消");
                        break;
                    }
                }
            }
        }
    }
}
```

### CancelAfter+ThrowIfCancellationRequested() 
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(1000); // 5秒后取消

            await Download2Async("https://www.baidu.com", 100,cts.Token);

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    //if (cancellationToken.IsCancellationRequested)
                    //{
                    //    Console.WriteLine("下载任务被取消");
                    //    break;
                    //}

                    cancellationToken.ThrowIfCancellationRequested();
                }
            }
        }
    }
}
```

![[Pasted image 20251202204749.png]]

### CancelAfter+传递CancellationToken
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(1000); // 5秒后取消

            await Download3Async("https://www.baidu.com", 100,cts.Token);

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    //if (cancellationToken.IsCancellationRequested)
                    //{
                    //    Console.WriteLine("下载任务被取消");
                    //    break;
                    //}

                    cancellationToken.ThrowIfCancellationRequested();
                }
            }
        }

        static async Task Download3Async(string url, int n, CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var resp = await client.GetAsync(url,cancellationToken);
                    string html = await resp.Content.ReadAsStringAsync();
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    
                }
            }
        }
    }
}

```

![[Pasted image 20251202205214.png]]

### 按键暂停
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(100000); // 5秒后取消

            Download3Async("https://www.baidu.com", 100,cts.Token);

            while(Console.ReadLine() != "q")
            {

            }
            cts.Cancel();
            Console.WriteLine("取消请求！！！！");
            Console.ReadLine();

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    //if (cancellationToken.IsCancellationRequested)
                    //{
                    //    Console.WriteLine("下载任务被取消");
                    //    break;
                    //}

                    cancellationToken.ThrowIfCancellationRequested();
                }
            }
        }

        static async Task Download3Async(string url, int n, CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var resp = await client.GetAsync(url,cancellationToken);
                    string html = await resp.Content.ReadAsStringAsync();
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    
                }
            }
        }
    }
}
```

# ASP.NET Core开发中
> 一般不需要自己处理CancelationTokenSource这些，只有做到能转发CancellationToken就转发即可。ASP.NET Core 会对用户请求中断进行处理

## Demo
