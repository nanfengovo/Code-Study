# await async 成对出现
# 不支持异步方法的情况
* 使用.Result(有返回值的情况)
* 使用.wait（没有返回值）
上面的两种方式有死锁的风险

# async await 原理

> 底层是movenext 类似于状态机的机制去切换

# 异步方法不等于多线程

# 异步方法可以不写async

# 暂停使用 await Task.Delay

# 异步中的CancellationToken

> 提高系统的健壮性和性能

>场景：有时用户需要提前终止任务，比如：请求超时，用户取消请求 。这时CancellationToken参数用于获得提前终止执行的信号


## CancellationToken结构体
None:空
bool IsCancellationRequested 是否取消
Register(Action calllback) 注册取消监听
ThrowIfCancellationRequested() 如果任务被取消，执行到这句话就抛异常
通过CancellationTokenSource 创建cancellationtoken结构体
CancelAfter() 超时后发出取消信号
Cancel()  发出取消信号

## Demo
> 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现

### CancelAfter+IsCancellationRequested
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(1000); // 5秒后取消

            await Download2Async("https://www.baidu.com", 100,cts.Token);

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    if (cancellationToken.IsCancellationRequested)
                    {
                        Console.WriteLine("下载任务被取消");
                        break;
                    }
                }
            }
        }
    }
}
```

### CancelAfter+ThrowIfCancellationRequested() 
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(1000); // 5秒后取消

            await Download2Async("https://www.baidu.com", 100,cts.Token);

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    //if (cancellationToken.IsCancellationRequested)
                    //{
                    //    Console.WriteLine("下载任务被取消");
                    //    break;
                    //}

                    cancellationToken.ThrowIfCancellationRequested();
                }
            }
        }
    }
}
```

![[Pasted image 20251202204749.png]]

### CancelAfter+传递CancellationToken
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(1000); // 5秒后取消

            await Download3Async("https://www.baidu.com", 100,cts.Token);

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    //if (cancellationToken.IsCancellationRequested)
                    //{
                    //    Console.WriteLine("下载任务被取消");
                    //    break;
                    //}

                    cancellationToken.ThrowIfCancellationRequested();
                }
            }
        }

        static async Task Download3Async(string url, int n, CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var resp = await client.GetAsync(url,cancellationToken);
                    string html = await resp.Content.ReadAsStringAsync();
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    
                }
            }
        }
    }
}

```

![[Pasted image 20251202205214.png]]

### 按键暂停
```
using System.Threading.Tasks;

namespace CancellationToken1
{
    internal class Program
    {
        static async Task Main(string[] args)
        {
            CancellationTokenSource cts = new CancellationTokenSource();
            cts.CancelAfter(100000); // 5秒后取消

            Download3Async("https://www.baidu.com", 100,cts.Token);

            while(Console.ReadLine() != "q")
            {

            }
            cts.Cancel();
            Console.WriteLine("取消请求！！！！");
            Console.ReadLine();

        }

        /*
         * 为下载一个网址N次的方法增加取消功能 分别用GetStringAsync+IsCancelationRequested 、GetStringAsync+ThrowIfCancellationRequested()、带CancellationToken 的GetAsync() 分别实现。取消分别用超时、用户敲按键（不能await）实现
         */

        /// <summary>
        /// 下载N次指定网址的HTML内容 不带取消的版本
        /// </summary>
        /// <param name="url"></param>
        /// <param name="n"></param>
        /// <returns></returns>
        static async Task DownloadAsync(string url,int n)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                }
            }
        }

        static async Task Download2Async(string url, int n,CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var html = await client.GetStringAsync(url);
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    //if (cancellationToken.IsCancellationRequested)
                    //{
                    //    Console.WriteLine("下载任务被取消");
                    //    break;
                    //}

                    cancellationToken.ThrowIfCancellationRequested();
                }
            }
        }

        static async Task Download3Async(string url, int n, CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var resp = await client.GetAsync(url,cancellationToken);
                    string html = await resp.Content.ReadAsStringAsync();
                    Console.WriteLine($"{DateTime.Now}:{html}");
                    
                }
            }
        }
    }
}
```

# ASP.NET Core开发中
> 一般不需要自己处理CancelationTokenSource这些，只有做到能转发CancellationToken就转发即可。ASP.NET Core 会对用户请求中断进行处理

## Demo
```
using ASPNETCore_CancellationToken2.Models;
using Microsoft.AspNetCore.Mvc;
using System.Diagnostics;
using System.Threading.Tasks;

namespace ASPNETCore_CancellationToken2.Controllers
{
    public class HomeController : Controller
    {
        public async Task<IActionResult> Index(CancellationToken cancellationToken)
        {
            await Download3Async("https://www.baidu.com", 10000, cancellationToken);
            return View();
        }

        public IActionResult Privacy()
        {
            return View();
        }

        [ResponseCache(Duration = 0, Location = ResponseCacheLocation.None, NoStore = true)]
        public IActionResult Error()
        {
            return View(new ErrorViewModel { RequestId = Activity.Current?.Id ?? HttpContext.TraceIdentifier });
        }

        static async Task Download3Async(string url, int n, CancellationToken cancellationToken)
        {
            using (HttpClient client = new HttpClient())
            {
                for (int i = 0; i < n; i++)
                {
                    var resp = await client.GetAsync(url, cancellationToken);
                    string html = await resp.Content.ReadAsStringAsync();
                    Debug.WriteLine(html);
                }
            }
        }
    }
}
```

# WhenAll
## Task类的重要方法：
```
1、Task<Task> WhenAny(IEnumerable<Task> tasks)等，任何一个Task完成，task就完成
2、Task<TResult[]> WhenAll<TRestult>(params Task<TResult>[] tasks)等，所有Task完成，Task才完成。用于等待多个任务执行结束，但是不在乎他们的执行顺序
3、FromResult() 创建普通数值的Task对象
```
# 异步编程不是很常用的
## 接口中的异步方法
```
async 是提示编译器为异步方法中的await代码进行分段处理的，而一个异步方法是否修饰了async对于方法的调用者来说是没区别的，因此对于接口中的方法或者抽象方法不能修饰为async
```

## 异步和yield
yield return 不仅能够简化数据的返回，而且可以让数据处理流水线化，提升性能

不能用这种写法：
```
static async Task<IEnumerable<string>> Test2()
{
	yield return("1");
	yield return("1");
	yield return("1");
}
```
要写成这样
```
	static async IAsyncEnumerable<string> Test2()
{
	yield return("1");
	yield return("1");
	yield return("1");
}
```

遍历的时候用await foreach
